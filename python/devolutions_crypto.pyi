"""
Devolutions Crypto Python Bindings

A high-performance cryptography library providing symmetric encryption, asymmetric encryption,
password hashing, digital signatures, and key derivation functions.
"""

from typing import Optional

class DevolutionsCryptoException(Exception):
    """Base exception class for all Devolutions Crypto errors."""
    ...

class Keypair:
    """
    A container for asymmetric encryption keypair.

    Attributes:
        public_key: The public key as bytes
        private_key: The private key as bytes
    """
    public_key: bytes
    private_key: bytes

def encrypt(
    data: bytes,
    key: bytes,
    aad: Optional[bytes] = None,
    version: int = 0
) -> bytes:
    """
    Encrypt data using symmetric encryption (AES-256-GCM).

    Args:
        data: The plaintext data to encrypt
        key: The encryption key (32 bytes for AES-256)
        aad: Optional Additional Authenticated Data for AEAD
        version: Ciphertext version (default: 0)

    Returns:
        The encrypted ciphertext as bytes

    Raises:
        DevolutionsCryptoException: If encryption fails or invalid parameters provided

    Example:
        >>> key = b'0' * 32  # 32-byte key
        >>> plaintext = b'Hello, World!'
        >>> ciphertext = encrypt(plaintext, key)
    """
    ...

def decrypt(
    data: bytes,
    key: bytes,
    aad: Optional[bytes] = None
) -> bytes:
    """
    Decrypt data that was encrypted with symmetric encryption.

    Args:
        data: The ciphertext to decrypt
        key: The decryption key
        aad: Optional Additional Authenticated Data (must match encryption AAD)

    Returns:
        The decrypted plaintext as bytes

    Raises:
        DevolutionsCryptoException: If decryption fails, authentication fails, or invalid ciphertext

    Example:
        >>> plaintext = decrypt(ciphertext, key)
    """
    ...

def encrypt_asymmetric(
    data: bytes,
    key: bytes,
    aad: Optional[bytes] = None,
    version: int = 0
) -> bytes:
    """
    Encrypt data using asymmetric encryption (X25519 + AES-256-GCM).

    Args:
        data: The plaintext data to encrypt
        key: The recipient's public key
        aad: Optional Additional Authenticated Data for AEAD
        version: Ciphertext version (default: 0)

    Returns:
        The encrypted ciphertext as bytes

    Raises:
        DevolutionsCryptoException: If encryption fails or invalid public key provided

    Example:
        >>> keypair = generate_keypair()
        >>> ciphertext = encrypt_asymmetric(b'secret', keypair.public_key)
    """
    ...

def decrypt_asymmetric(
    data: bytes,
    key: bytes,
    aad: Optional[bytes] = None
) -> bytes:
    """
    Decrypt data that was encrypted with asymmetric encryption.

    Args:
        data: The ciphertext to decrypt
        key: The recipient's private key
        aad: Optional Additional Authenticated Data (must match encryption AAD)

    Returns:
        The decrypted plaintext as bytes

    Raises:
        DevolutionsCryptoException: If decryption fails or invalid private key provided

    Example:
        >>> plaintext = decrypt_asymmetric(ciphertext, keypair.private_key)
    """
    ...

def hash_password(
    password: bytes,
    iterations: int = 10000,
    version: int = 0
) -> bytes:
    """
    Hash a password using a secure password hashing algorithm (PBKDF2).

    Args:
        password: The password to hash
        iterations: Number of iterations for the KDF (default: 10000, higher is more secure)
        version: Password hash version (default: 0)

    Returns:
        The password hash as bytes (contains salt and parameters)

    Raises:
        DevolutionsCryptoException: If hashing fails or invalid parameters provided

    Example:
        >>> password = b'my_secure_password'
        >>> hash_value = hash_password(password, iterations=100000)
    """
    ...

def verify_password(
    password: bytes,
    hash: bytes
) -> bool:
    """
    Verify a password against a previously generated hash.

    Args:
        password: The password to verify
        hash: The hash to verify against (generated by hash_password)

    Returns:
        True if the password matches the hash, False otherwise

    Raises:
        DevolutionsCryptoException: If the hash format is invalid

    Example:
        >>> is_valid = verify_password(b'my_secure_password', hash_value)
    """
    ...

def derive_key_pbkdf2(
    key: bytes,
    salt: Optional[bytes] = None,
    iterations: int = 10000,
    length: int = 32
) -> bytes:
    """
    Derive a cryptographic key from input material using PBKDF2.

    Args:
        key: The input key material
        salt: Optional salt (default: empty bytes)
        iterations: Number of iterations (default: 10000, higher is more secure)
        length: Length of the derived key in bytes (default: 32)

    Returns:
        The derived key as bytes

    Raises:
        DevolutionsCryptoException: If key derivation fails

    Example:
        >>> derived = derive_key_pbkdf2(b'password', b'salt', iterations=100000, length=32)
    """
    ...

def derive_key_argon2(
    key: bytes,
    parameters: bytes
) -> bytes:
    """
    Derive a cryptographic key from input material using Argon2.

    Args:
        key: The input key material
        parameters: Argon2 parameters (serialized)

    Returns:
        The derived key as bytes

    Raises:
        DevolutionsCryptoException: If key derivation fails or invalid parameters

    Example:
        >>> derived = derive_key_argon2(b'password', parameters)
    """
    ...

def generate_keypair(version: int = 0) -> Keypair:
    """
    Generate a new asymmetric encryption keypair (X25519).

    Args:
        version: Key version (default: 0)

    Returns:
        A Keypair object containing public_key and private_key attributes

    Raises:
        DevolutionsCryptoException: If keypair generation fails or invalid version

    Example:
        >>> keypair = generate_keypair()
        >>> public_key = keypair.public_key
        >>> private_key = keypair.private_key
    """
    ...

def generate_signing_keypair(version: int = 0) -> bytes:
    """
    Generate a new signing keypair (Ed25519).

    Args:
        version: Key version (default: 0)

    Returns:
        The signing keypair as bytes (contains both private and public key)

    Raises:
        DevolutionsCryptoException: If keypair generation fails or invalid version

    Example:
        >>> signing_keypair = generate_signing_keypair()
    """
    ...

def get_signing_public_key(keypair: bytes) -> bytes:
    """
    Extract the public key from a signing keypair.

    Args:
        keypair: The signing keypair (generated by generate_signing_keypair)

    Returns:
        The public key as bytes

    Raises:
        DevolutionsCryptoException: If the keypair format is invalid

    Example:
        >>> public_key = get_signing_public_key(signing_keypair)
    """
    ...

def sign(
    data: bytes,
    keypair: bytes,
    version: int = 0
) -> bytes:
    """
    Sign data using a signing keypair (Ed25519).

    Args:
        data: The data to sign
        keypair: The signing keypair (generated by generate_signing_keypair)
        version: Signature version (default: 0)

    Returns:
        The signature as bytes

    Raises:
        DevolutionsCryptoException: If signing fails or invalid keypair/version

    Example:
        >>> signing_keypair = generate_signing_keypair()
        >>> signature = sign(b'message', signing_keypair)
    """
    ...

def verify_signature(
    data: bytes,
    public_key: bytes,
    signature: bytes
) -> bool:
    """
    Verify a signature against data using a public key.

    Args:
        data: The data that was signed
        public_key: The signer's public key
        signature: The signature to verify

    Returns:
        True if the signature is valid, False otherwise

    Raises:
        DevolutionsCryptoException: If the signature or public key format is invalid

    Example:
        >>> public_key = get_signing_public_key(signing_keypair)
        >>> is_valid = verify_signature(b'message', public_key, signature)
    """
    ...

__all__ = [
    'DevolutionsCryptoException',
    'Keypair',
    'encrypt',
    'decrypt',
    'encrypt_asymmetric',
    'decrypt_asymmetric',
    'hash_password',
    'verify_password',
    'derive_key_pbkdf2',
    'derive_key_argon2',
    'generate_keypair',
    'generate_signing_keypair',
    'get_signing_public_key',
    'sign',
    'verify_signature',
]
